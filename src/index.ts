// src/index.ts
/**
 * Cloudflare Worker for managing Claude API access through session keys (SKs).
 * Provides endpoints for users to login (randomly or specifically) and for admins to manage SKs.
 * Utilizes KV storage for email-to-SK mappings and supports optional Sentry integration for error tracking.
 */

import * as auth from './auth';
import * as githubAuth from './githubAuth';
import * as userManagement from './userManagement';

// --- Type Definitions ---

/**
 * Defines the environment variables and bindings expected by the Worker.
 * These are configured in the Cloudflare dashboard or via wrangler.toml/wrangler.jsonc.
 */
interface Env {
  /**
   * The KV Namespace used to store the email-to-SK mapping.
   * This is where `EMAIL_TO_SK_MAP` key holds the JSON string of mappings.
   */
  CLAUDE_KV: KVNamespace;
  /**
   * The password required for accessing administrative endpoints (e.g., /api/admin/*).
   * This should be set as a Secret in the Worker's settings.
   */
  ADMIN_PASSWORD: string;
  /**
   * The base URL for the Claude API (e.g., https://demo.fuclaude.com).
   * Used to construct the final login URL.
   */
  BASE_URL: string;
  /**
   * Optional: The token expiration time in seconds.
   * Defaults to 0 (never expires) if not set.
   * Can be overridden by the 'expires_in' parameter in the login request.
   */
  TOKEN_EXPIRES_IN?: string;

  // LinuxDO OAuth Configuration
  LINUXDO_CLIENT_ID?: string;
  LINUXDO_CLIENT_SECRET?: string;
  LINUXDO_REDIRECT_URI?: string;
  FRONTEND_URL?: string;

  // GitHub OAuth Configuration
  GITHUB_CLIENT_ID?: string;
  GITHUB_CLIENT_SECRET?: string;
  GITHUB_REDIRECT_URI?: string;
}

/**
 * Represents the structure of the email to session key mapping stored in KV.
 * Keys are email addresses (string), and values are their corresponding session keys (sk, string).
 */
interface EmailSkMap {
  [email: string]: string;
}

/**
 * Defines the structure of the request body for the /api/login endpoint.
 */
interface LoginRequest {
  /**
   * The mode of login: 'specific' (requires email and unique_name) or 'random'.
   */
  mode: 'specific' | 'random';
  /**
   * Optional: The email address for 'specific' mode login.
   */
  email?: string;
  /**
   * Optional: A unique identifier for the session, required for 'specific' mode.
   * For 'random' mode, this is generated by the worker.
   */
  unique_name?: string;
  /**
   * Optional: The desired token expiration time in seconds.
   * Overrides the default and the TOKEN_EXPIRES_IN environment variable.
   * A value of 0 means the token should not expire.
   */
  expires_in?: number;
}

/**
 * Defines the structure of the request body for the /api/admin/login endpoint.
 * Inherits from LoginRequest and requires an admin password.
 */
interface AdminLoginRequest extends LoginRequest, AdminRequestBase { }

/**
 * Base interface for administrative requests, requiring an admin password.
 */
interface AdminRequestBase {
  /**
   * The password to authenticate administrative actions.
   * Must match the ADMIN_PASSWORD secret.
   */
  admin_password: string;
}

/**
 * Defines the structure for adding a new email-SK pair via an admin endpoint.
 * Inherits admin_password from AdminRequestBase.
 */
interface AdminAddRequest extends AdminRequestBase {
  /**
   * The email address to add or update.
   */
  email: string;
  /**
   * The session key (sk) associated with the email.
   */
  sk: string;
}

/**
 * Defines the structure for deleting an email-SK pair via an admin endpoint.
 * Inherits admin_password from AdminRequestBase.
 */
interface AdminDeleteRequest extends AdminRequestBase {
  /**
   * The email address to delete from the mapping.
   */
  email: string;
}

/**
 * Defines the structure for updating an email-SK pair via an admin endpoint.
 * Inherits admin_password from AdminRequestBase.
 */
interface AdminUpdateRequest extends AdminRequestBase {
  /**
   * The current email address to identify the record to be updated.
   */
  email: string;
  /**
   * Optional: The new email address to replace the old one.
   */
  new_email?: string;
  /**
   * Optional: The new session key to replace the old one.
   */
  new_sk?: string;
}

/**
 * Defines a single action within a batch request.
 */
interface AdminBatchAction {
  action: 'add' | 'delete';
  email: string;
  sk?: string; // Required for 'add', ignored for 'delete'
}

/**
 * Defines the structure for a batch processing request.
 * Inherits admin_password from AdminRequestBase.
 */
interface AdminBatchRequest extends AdminRequestBase {
  actions: AdminBatchAction[];
}

// --- Helper Functions ---

/**
 * Creates a JSON response with appropriate CORS headers.
 * @param data The data to be stringified into the response body.
 * @param status The HTTP status code for the response (default is 200).
 * @param extraHeaders Additional headers to include in the response.
 * @param origin Optional origin for CORS (required for credentials mode).
 * @returns A Response object.
 */
const jsonResponse = (data: any, status = 200, extraHeaders = {}, origin?: string) => {
  const headers: Record<string, string> = {
    'Content-Type': 'application/json',
    'Access-Control-Allow-Origin': origin || '*',
    'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
    'Access-Control-Allow-Headers': 'Content-Type, Authorization',
    ...extraHeaders,
  };
  if (origin) {
    headers['Access-Control-Allow-Credentials'] = 'true';
  }
  return new Response(JSON.stringify(data, null, 2), { status, headers });
};

/**
 * Handles CORS preflight (OPTIONS) requests.
 * @param request The incoming Request object.
 * @returns A Response object with appropriate CORS headers for preflight.
 */
const handleOptions = (request: Request) => {
  const origin = request.headers.get('Origin') || '*';
  const headers: Record<string, string> = {
    'Access-Control-Allow-Origin': origin,
    'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
    'Access-Control-Allow-Headers': 'Content-Type, Authorization',
  };
  if (origin !== '*') {
    headers['Access-Control-Allow-Credentials'] = 'true';
  }
  return new Response(null, { headers });
};

/**
 * Sorts an array of email addresses, primarily by domain, then by the local part.
 * @param emails An array of email strings.
 * @returns A new array with sorted email strings.
 */
const sortEmails = (emails: string[]): string[] => {
  return emails.sort((a, b) => {
    const [, domainA = ''] = a.split('@'); // Robust split with default
    const [, domainB = ''] = b.split('@');
    if (domainA !== domainB) {
      return domainA.localeCompare(domainB); // Sort by domain first
    }
    return a.localeCompare(b); // Then by full email
  });
};

/**
 * Retrieves and parses the EMAIL_TO_SK_MAP from KV storage.
 * @param env The Environment object containing the KV namespace.
 * @returns A Promise that resolves to the EmailSkMap object. Returns an empty object if not found or on parse error.
 */
async function getEmailSkMap(env: Env): Promise<EmailSkMap> {
  const mapStr = await env.CLAUDE_KV.get('EMAIL_TO_SK_MAP');
  if (!mapStr) {
    console.log("EMAIL_TO_SK_MAP not found in KV, returning empty map.");
    return {}; // Return an empty object if KV key doesn't exist
  }
  try {
    return JSON.parse(mapStr) as EmailSkMap;
  } catch (e) {
    console.error("Error parsing EMAIL_TO_SK_MAP from KV:", e);
    return {}; // Return empty on parse error to prevent worker crashes
  }
}

// --- Account Status Types ---
interface AccountStatus {
  isValid: boolean;
  lastChecked: number;
  message?: string;
}

interface AccountStatusMap {
  [email: string]: AccountStatus;
}

/**
 * Retrieves the ACCOUNT_STATUS_MAP from KV storage.
 */
async function getAccountStatusMap(env: Env): Promise<AccountStatusMap> {
  const mapStr = await env.CLAUDE_KV.get('ACCOUNT_STATUS_MAP');
  if (!mapStr) {
    return {};
  }
  try {
    return JSON.parse(mapStr) as AccountStatusMap;
  } catch (e) {
    console.error("Error parsing ACCOUNT_STATUS_MAP from KV:", e);
    return {};
  }
}

// --- Main Worker Fetch Handler ---
export default {
  /**
   * Handles incoming HTTP requests to the Worker.
   * @param request The incoming Request object.
   * @param env The Environment object with bindings and secrets.
   * @param ctx The ExecutionContext for the request.
   * @returns A Promise that resolves to a Response object.
   */
  async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {
    // Handle CORS preflight requests first
    if (request.method === 'OPTIONS') {
      return handleOptions(request);
    }


    try {
      const url = new URL(request.url);

      // --- User Endpoints ---

      // GET /api/emails: Lists available email addresses (sorted)
      if (url.pathname === '/api/emails' && request.method === 'GET') {
        const emailMap = await getEmailSkMap(env);
        const sortedEmails = sortEmails(Object.keys(emailMap));
        return jsonResponse({ emails: sortedEmails });
      }

      // POST /api/login: Handles user login requests (specific or random)
      if (url.pathname === '/api/login' && request.method === 'POST') {
        let body: LoginRequest;
        try {
          body = await request.json();
        } catch (e) {
          return jsonResponse({ error: 'Invalid JSON request body.' }, 400);
        }

        const emailMap = await getEmailSkMap(env);
        let sk: string | undefined;
        let uniqueName: string;
        let selectedEmailForLog: string | undefined; // For logging purposes

        if (body.mode === 'random') {
          const emails = Object.keys(emailMap);
          if (emails.length === 0) {
            return jsonResponse({ error: 'No accounts available for random selection' }, 503); // Service Unavailable
          }
          selectedEmailForLog = emails[Math.floor(Math.random() * emails.length)];
          sk = emailMap[selectedEmailForLog];
          uniqueName = `rand_${Date.now().toString(36)}${Math.random().toString(36).substring(2, 7)}`; // More unique random name
        } else if (body.mode === 'specific') {
          if (!body.email || !body.unique_name) {
            return jsonResponse({ error: 'Email and unique_name are required for specific mode' }, 400);
          }
          selectedEmailForLog = body.email;
          sk = emailMap[selectedEmailForLog];
          uniqueName = body.unique_name;
        } else {
          return jsonResponse({ error: 'Invalid login mode specified. Must be \"specific\" or \"random\".' }, 400);
        }

        if (!sk) {
          const errorMessage = `Account for ${selectedEmailForLog || 'random selection'} not found or SK is invalid`;
          console.error(`Login attempt for ${selectedEmailForLog || 'random'} failed: SK not found.`);
          return jsonResponse({ error: errorMessage }, 404); // Not Found
        }

        // --- Token Expiration Logic for User Endpoint ---
        let expiresIn: number;
        let warning: string | undefined;
        const maxExpiresIn = env.TOKEN_EXPIRES_IN ? parseInt(env.TOKEN_EXPIRES_IN, 10) : 0;

        if (typeof body.expires_in === 'number') {
          expiresIn = body.expires_in;
          // If a maximum duration is set via environment variable and it's not 0 (unlimited)
          if (maxExpiresIn > 0 && expiresIn > maxExpiresIn) {
            warning = `Requested expiration of ${expiresIn}s exceeds the maximum allowed of ${maxExpiresIn}s. The expiration has been adjusted.`;
            expiresIn = maxExpiresIn;
          }
        } else {
          // Default to the max allowed if not specified in request
          // If maxExpiresIn is 0 (not set/unlimited), default to 8 hours (28800s) for security
          const defaultExpiration = 28800;

          if (maxExpiresIn > 0) {
            expiresIn = maxExpiresIn;
          } else {
            // If env var is not set, we now default to 8 hours instead of unlimited
            expiresIn = defaultExpiration;
          }
        }

        // --- Claude API Token Exchange ---
        const oauthPayload = { session_key: sk, unique_name: uniqueName, expires_in: expiresIn };
        const oauthResponse = await fetch(`${env.BASE_URL}/manage-api/auth/oauth_token`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(oauthPayload),
        });

        if (!oauthResponse.ok) {
          const errorText = await oauthResponse.text();
          const logMessage = `Token exchange failed for ${selectedEmailForLog} (SK preview: ${sk.slice(0, 15)}...): ${oauthResponse.status}`;
          console.error(`${logMessage} - Response: ${errorText}`);
          throw new Error(`Token exchange failed with status ${oauthResponse.status}. Check server logs for details.`);
        }

        const oauthData: any = await oauthResponse.json();
        if (!oauthData.login_url) {
          const logMessage = `Token exchange response for ${selectedEmailForLog} missing login_url.`;
          console.error(`${logMessage} - Response: ${JSON.stringify(oauthData)}`);
          throw new Error('Token exchange successful, but login_url was not returned.');
        }

        const responsePayload: { login_url: string; warning?: string } = {
          login_url: `${env.BASE_URL}${oauthData.login_url}`
        };
        if (warning) {
          responsePayload.warning = warning;
        }
        return jsonResponse(responsePayload);
      }

      // POST /api/contribute: Public endpoint for users to contribute their SK to the pool
      if (url.pathname === '/api/contribute' && request.method === 'POST') {
        const body = await request.json().catch(() => ({})) as { email?: string; sk?: string };

        if (!body.email || !body.sk) {
          return jsonResponse({ error: 'Email and SK are required.' }, 400);
        }

        // Validate email format
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        if (!emailRegex.test(body.email)) {
          return jsonResponse({ error: 'Invalid email format.' }, 400);
        }

        // Validate SK format (should start with 'sk-ant-')
        if (!body.sk.startsWith('sk-ant-')) {
          return jsonResponse({ error: 'Invalid SK format. SK should start with "sk-ant-".' }, 400);
        }

        // Get current email map
        const emailMap = await getEmailSkMap(env);

        // Check if email already exists
        if (emailMap[body.email]) {
          return jsonResponse({ error: 'This email already exists in the pool.' }, 409);
        }

        // Add the new email-SK pair
        emailMap[body.email] = body.sk;

        // Save back to KV
        await env.CLAUDE_KV.put('EMAIL_TO_SK_MAP', JSON.stringify(emailMap));

        console.log(`Contribution: Account ${body.email} added to pool.`);
        return jsonResponse({ message: 'Thank you! Your account has been added to the pool.', email: body.email });
      }

      // --- LinuxDO OAuth Endpoints ---

      // GET /api/auth/login: Redirect to LinuxDO OAuth
      if (url.pathname === '/api/auth/login' && request.method === 'GET') {
        if (!env.LINUXDO_CLIENT_ID || !env.LINUXDO_REDIRECT_URI || !env.FRONTEND_URL) {
          return jsonResponse({ error: 'OAuth not configured. Please set LINUXDO_CLIENT_ID, LINUXDO_REDIRECT_URI, and FRONTEND_URL.' }, 500);
        }
        return auth.handleOAuthLogin({
          clientId: env.LINUXDO_CLIENT_ID,
          clientSecret: env.LINUXDO_CLIENT_SECRET || '',
          redirectUri: env.LINUXDO_REDIRECT_URI,
          frontendUrl: env.FRONTEND_URL,
        });
      }

      // GET /api/auth/callback/linux-do: Handle OAuth callback
      if (url.pathname === '/api/auth/callback/linux-do' && request.method === 'GET') {
        if (!env.LINUXDO_CLIENT_ID || !env.LINUXDO_CLIENT_SECRET || !env.LINUXDO_REDIRECT_URI || !env.FRONTEND_URL) {
          return jsonResponse({ error: 'OAuth not configured. Please set LINUXDO_CLIENT_ID, LINUXDO_CLIENT_SECRET, LINUXDO_REDIRECT_URI, and FRONTEND_URL.' }, 500);
        }
        return auth.handleOAuthCallback(request, {
          clientId: env.LINUXDO_CLIENT_ID,
          clientSecret: env.LINUXDO_CLIENT_SECRET,
          redirectUri: env.LINUXDO_REDIRECT_URI,
          frontendUrl: env.FRONTEND_URL,
        }, env.CLAUDE_KV);
      }

      // GET /api/auth/me: Get current user info
      if (url.pathname === '/api/auth/me' && request.method === 'GET') {
        return auth.getCurrentUser(request, env.CLAUDE_KV);
      }

      // POST /api/auth/logout: Logout
      if (url.pathname === '/api/auth/logout' && request.method === 'POST') {
        return auth.handleLogout(request, env.CLAUDE_KV);
      }

      // --- GitHub OAuth Endpoints ---

      // GET /api/auth/github/login: Redirect to GitHub OAuth
      if (url.pathname === '/api/auth/github/login' && request.method === 'GET') {
        if (!env.GITHUB_CLIENT_ID || !env.GITHUB_REDIRECT_URI || !env.FRONTEND_URL) {
          return jsonResponse({ error: 'GitHub OAuth not configured. Please set GITHUB_CLIENT_ID, GITHUB_REDIRECT_URI, and FRONTEND_URL.' }, 500);
        }
        return githubAuth.handleGitHubOAuthLogin({
          clientId: env.GITHUB_CLIENT_ID,
          clientSecret: env.GITHUB_CLIENT_SECRET || '',
          redirectUri: env.GITHUB_REDIRECT_URI,
          frontendUrl: env.FRONTEND_URL,
        });
      }

      // GET /api/auth/callback/github: Handle GitHub OAuth callback
      if (url.pathname === '/api/auth/callback/github' && request.method === 'GET') {
        if (!env.GITHUB_CLIENT_ID || !env.GITHUB_CLIENT_SECRET || !env.GITHUB_REDIRECT_URI || !env.FRONTEND_URL) {
          return jsonResponse({ error: 'GitHub OAuth not configured. Please set GITHUB_CLIENT_ID, GITHUB_CLIENT_SECRET, GITHUB_REDIRECT_URI, and FRONTEND_URL.' }, 500);
        }
        return githubAuth.handleGitHubOAuthCallback(request, {
          clientId: env.GITHUB_CLIENT_ID,
          clientSecret: env.GITHUB_CLIENT_SECRET,
          redirectUri: env.GITHUB_REDIRECT_URI,
          frontendUrl: env.FRONTEND_URL,
        }, env.CLAUDE_KV);
      }

      // --- Admin Endpoints (prefixed with /api/admin) ---
      if (url.pathname.startsWith('/api/admin')) {
        // Centralized admin password extraction and validation for POST, PUT, DELETE
        if (request.method === 'POST' || request.method === 'PUT' || request.method === 'DELETE') {
          let adminRequestData: AdminRequestBase;
          try {
            adminRequestData = await request.clone().json(); // Clone for body re-read if needed
          } catch (e) {
            return jsonResponse({ error: 'Invalid JSON body for admin request.' }, 400);
          }
          if (adminRequestData.admin_password !== env.ADMIN_PASSWORD) {
            return jsonResponse({ error: 'Unauthorized. Invalid admin password.' }, 401);
          }
        }

        // POST /api/admin/list: Lists all email-SK pairs (requires admin password in body)
        if (url.pathname === '/api/admin/list' && request.method === 'POST') {
          // Password check is now handled by the centralized logic above for POST requests
          const emailMap = await getEmailSkMap(env);
          const statusMap = await getAccountStatusMap(env);

          const sortedEmails = sortEmails(Object.keys(emailMap));
          const listWithIndexAndPreview = sortedEmails.map((email, index) => {
            const status = statusMap[email];
            return {
              index: index + 1,
              email: email,
              sk_preview: emailMap[email] ? `${emailMap[email].slice(0, 20)}...${emailMap[email].slice(-10)}` : "SK_INVALID_OR_MISSING",
              status: status ? {
                isValid: status.isValid,
                lastChecked: status.lastChecked,
                message: status.message
              } : undefined
            };
          });
          return jsonResponse(listWithIndexAndPreview);
        }

        // POST /api/admin/login: Admin version of the login endpoint with no expiration limits
        if (url.pathname === '/api/admin/login' && request.method === 'POST') {
          const body: AdminLoginRequest = await request.json();
          const emailMap = await getEmailSkMap(env);
          let sk: string | undefined;
          let uniqueName: string;
          let selectedEmailForLog: string | undefined;

          if (body.mode === 'random') {
            const emails = Object.keys(emailMap);
            if (emails.length === 0) {
              return jsonResponse({ error: 'No accounts available for random selection' }, 503);
            }
            selectedEmailForLog = emails[Math.floor(Math.random() * emails.length)];
            sk = emailMap[selectedEmailForLog];
            uniqueName = `rand_${Date.now().toString(36)}${Math.random().toString(36).substring(2, 7)}`;
          } else if (body.mode === 'specific') {
            if (!body.email || !body.unique_name) {
              return jsonResponse({ error: 'Email and unique_name are required for specific mode' }, 400);
            }
            selectedEmailForLog = body.email;
            sk = emailMap[selectedEmailForLog];
            uniqueName = body.unique_name;
          } else {
            return jsonResponse({ error: 'Invalid login mode specified. Must be "specific" or "random".' }, 400);
          }

          if (!sk) {
            const errorMessage = `Account for ${selectedEmailForLog || 'random selection'} not found or SK is invalid`;
            return jsonResponse({ error: errorMessage }, 404);
          }

          // Admin has no expiration limit, defaults to 0 if not provided.
          const expiresIn = typeof body.expires_in === 'number' ? body.expires_in : 0;

          const oauthPayload = { session_key: sk, unique_name: uniqueName, expires_in: expiresIn };
          const oauthResponse = await fetch(`${env.BASE_URL}/manage-api/auth/oauth_token`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(oauthPayload),
          });

          if (!oauthResponse.ok) {
            const errorText = await oauthResponse.text();
            const logMessage = `Admin Token exchange failed for ${selectedEmailForLog}: ${oauthResponse.status}`;
            console.error(`${logMessage} - Response: ${errorText}`);
            throw new Error(`Token exchange failed with status ${oauthResponse.status}.`);
          }

          const oauthData: any = await oauthResponse.json();
          if (!oauthData.login_url) {
            throw new Error('Token exchange successful, but login_url was not returned.');
          }
          return jsonResponse({ login_url: `${env.BASE_URL}${oauthData.login_url}` });
        }

        // POST /api/admin/add: Adds a new email-SK pair
        // Password check already happened above for POST requests
        if (url.pathname === '/api/admin/add' && request.method === 'POST') {
          const body: AdminAddRequest = await request.json(); // Re-read body, safe as password check cloned
          if (!body.email || !body.sk) {
            return jsonResponse({ error: 'Email and SK are required for adding an account.' }, 400);
          }
          const emailMap = await getEmailSkMap(env);
          if (emailMap[body.email]) {
            return jsonResponse({ error: `Email ${body.email} already exists. Use update if intended.` }, 409); // 409 Conflict
          }
          emailMap[body.email] = body.sk;
          await env.CLAUDE_KV.put('EMAIL_TO_SK_MAP', JSON.stringify(emailMap));
          console.log(`Admin action: Account ${body.email} added successfully.`);
          return jsonResponse({ message: `Account ${body.email} added successfully.` });
        }

        // POST /api/admin/delete: Deletes an email-SK pair
        // Password check already happened above for POST requests
        if (url.pathname === '/api/admin/delete' && request.method === 'POST') {
          const body: AdminDeleteRequest = await request.json(); // Re-read body
          if (!body.email) {
            return jsonResponse({ error: 'Email is required for deleting an account.' }, 400);
          }
          const emailMap = await getEmailSkMap(env);
          if (!emailMap[body.email]) {
            return jsonResponse({ error: `Email ${body.email} not found. Cannot delete.` }, 404);
          }
          delete emailMap[body.email];
          await env.CLAUDE_KV.put('EMAIL_TO_SK_MAP', JSON.stringify(emailMap));
          console.log(`Admin action: Account ${body.email} deleted successfully.`);
          return jsonResponse({ message: `Account ${body.email} deleted successfully.` });
        }

        // POST /api/admin/update: Updates an email-SK pair
        // Password check already happened above for POST requests
        if (url.pathname === '/api/admin/update' && request.method === 'POST') {
          const body: AdminUpdateRequest = await request.json();
          if (!body.email) {
            return jsonResponse({ error: 'The original email is required to identify the account to update.' }, 400);
          }
          if (!body.new_email && !body.new_sk) {
            return jsonResponse({ error: 'Either new_email or new_sk must be provided to perform an update.' }, 400);
          }

          const emailMap = await getEmailSkMap(env);

          if (!emailMap[body.email]) {
            return jsonResponse({ error: `Account for ${body.email} not found. Cannot update.` }, 404);
          }

          // Check for new_email conflict before proceeding
          if (body.new_email && body.new_email !== body.email && emailMap[body.new_email]) {
            return jsonResponse({ error: `The new email ${body.new_email} already exists. Cannot update.` }, 409);
          }

          // Store the original SK before any potential modification
          const originalSk = emailMap[body.email];

          // If renaming the email, we must delete the old entry
          if (body.new_email && body.new_email !== body.email) {
            delete emailMap[body.email];
          }

          // Determine the final email key and SK value
          const finalEmail = body.new_email || body.email;
          const finalSk = body.new_sk || originalSk;

          emailMap[finalEmail] = finalSk;

          await env.CLAUDE_KV.put('EMAIL_TO_SK_MAP', JSON.stringify(emailMap));
          console.log(`Admin action: Account ${body.email} updated successfully. New details -> Email: ${finalEmail}, SK updated: ${!!body.new_sk}`);
          return jsonResponse({ message: `Account ${body.email} has been updated successfully.` });
        }

        // POST /api/admin/check-health: Check validity of all accounts
        if (url.pathname === '/api/admin/check-health' && request.method === 'POST') {
          // Password check already happened via AdminRequestBase check logic
          const emailMap = await getEmailSkMap(env);
          const emails = Object.keys(emailMap);
          const statusMap: AccountStatusMap = {};

          console.log(`Starting health check for ${emails.length} accounts...`);

          // Concurrently check all accounts
          const checkPromises = emails.map(async (email) => {
            const sk = emailMap[email];
            // Validate SK format roughly first
            if (!sk || !sk.startsWith('sk-ant-')) {
              statusMap[email] = { isValid: false, lastChecked: Date.now(), message: 'Invalid SK format' };
              return;
            }

            try {
              // We use the /api/organizations endpoint to verify the session key
              // This is a lightweight request that requires authentication
              const response = await fetch(`${env.BASE_URL}/api/organizations`, {
                method: 'GET',
                headers: {
                  'Content-Type': 'application/json',
                  'Cookie': `sessionKey=${sk}`
                }
              });

              if (response.ok) {
                statusMap[email] = { isValid: true, lastChecked: Date.now() };
              } else {
                console.warn(`Health check failed for ${email}: ${response.status} ${response.statusText}`);
                // If 403 or 401, it's definitely invalid
                statusMap[email] = {
                  isValid: false,
                  lastChecked: Date.now(),
                  message: `HTTP ${response.status}`
                };
              }
            } catch (error: any) {
              console.error(`Health check error for ${email}:`, error);
              statusMap[email] = {
                isValid: false,
                lastChecked: Date.now(),
                message: error.message || 'Network Error'
              };
            }
          });

          await Promise.all(checkPromises);

          // Update the status map in KV
          await env.CLAUDE_KV.put('ACCOUNT_STATUS_MAP', JSON.stringify(statusMap));

          return jsonResponse({
            message: 'Health check completed.',
            stats: {
              total: emails.length,
              valid: Object.values(statusMap).filter(s => s.isValid).length,
              invalid: Object.values(statusMap).filter(s => !s.isValid).length
            },
            results: statusMap
          });
        }

        // POST /api/admin/batch: Processes multiple add/delete operations in one request
        if (url.pathname === '/api/admin/batch' && request.method === 'POST') {
          const body: AdminBatchRequest = await request.json();
          if (!body.actions || !Array.isArray(body.actions)) {
            return jsonResponse({ error: 'The "actions" array is required for batch processing.' }, 400);
          }

          const emailMap = await getEmailSkMap(env);
          const results = [];
          let modified = false;

          for (const item of body.actions) {
            switch (item.action) {
              case 'add':
                if (!item.email || !item.sk) {
                  results.push({ email: item.email, status: 'failed', reason: 'Email and SK are required for add action.' });
                  continue;
                }
                if (emailMap[item.email]) {
                  // To make it idempotent, we can treat adding an existing key as an update.
                  emailMap[item.email] = item.sk;
                  results.push({ email: item.email, status: 'updated' });
                } else {
                  emailMap[item.email] = item.sk;
                  results.push({ email: item.email, status: 'added' });
                }
                modified = true;
                break;

              case 'delete':
                if (!item.email) {
                  results.push({ email: 'N/A', status: 'failed', reason: 'Email is required for delete action.' });
                  continue;
                }
                if (emailMap[item.email]) {
                  delete emailMap[item.email];
                  results.push({ email: item.email, status: 'deleted' });
                  modified = true;
                } else {
                  results.push({ email: item.email, status: 'skipped', reason: 'Email not found.' });
                }
                break;

              default:
                results.push({ email: item.email, status: 'failed', reason: `Unknown action: ${item.action}` });
            }
          }

          if (modified) {
            await env.CLAUDE_KV.put('EMAIL_TO_SK_MAP', JSON.stringify(emailMap));
            console.log(`Admin action: Batch processing completed with ${body.actions.length} actions.`);
          }

          return jsonResponse({ message: 'Batch processing complete.', results });
        }


        // --- User Management Endpoints ---
        // Handle /api/admin/users, /api/admin/users/ban, /api/admin/users/unban
        const userManagementResponse = await userManagement.handleUserManagement(request, url, env.CLAUDE_KV);
        if (userManagementResponse) {
          return userManagementResponse;
        }

        // If an admin path was hit but not any of the specific routes above
        return jsonResponse({ error: 'Admin endpoint not found.' }, 404);

      } // End of /api/admin block

      // Fallback for any other route not matched
      return jsonResponse({ error: 'Not Found. The requested endpoint does not exist.' }, 404);

    } catch (error: any) {
      console.error("Worker encountered an unhandled error:", error.stack || error);
      // Return a generic error message to the client
      return jsonResponse({ error: 'An internal server error occurred. Please try again later.' }, 500);
    }
  },
};